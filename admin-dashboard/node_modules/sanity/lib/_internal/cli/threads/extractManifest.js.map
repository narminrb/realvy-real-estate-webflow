{"version":3,"file":"extractManifest.js","sources":["../../../../src/_internal/manifest/manifestTypeHelpers.ts","../../../../src/_internal/manifest/extractWorkspaceManifest.ts","../../../../src/_internal/cli/threads/extractManifest.ts"],"sourcesContent":["import {\n  type CrossDatasetReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type SchemaType,\n} from '@sanity/types'\n\nconst DEFAULT_IMAGE_FIELDS = ['asset', 'hotspot', 'crop']\nconst DEFAULT_FILE_FIELDS = ['asset']\nconst DEFAULT_GEOPOINT_FIELDS = ['lat', 'lng', 'alt']\nconst DEFAULT_SLUG_FIELDS = ['current', 'source']\n\nexport function getCustomFields(type: ObjectSchemaType): (ObjectField & {fieldset?: string})[] {\n  const fields = type.fieldsets\n    ? type.fieldsets.flatMap((fs) => {\n        if (fs.single) {\n          return fs.field\n        }\n        return fs.fields.map((field) => ({\n          ...field,\n          fieldset: fs.name,\n        }))\n      })\n    : type.fields\n\n  if (isType(type, 'block')) {\n    return []\n  }\n  if (isType(type, 'slug')) {\n    return fields.filter((f) => !DEFAULT_SLUG_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'geopoint')) {\n    return fields.filter((f) => !DEFAULT_GEOPOINT_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'image')) {\n    return fields.filter((f) => !DEFAULT_IMAGE_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'file')) {\n    return fields.filter((f) => !DEFAULT_FILE_FIELDS.includes(f.name))\n  }\n  return fields\n}\n\nexport function isReference(type: SchemaType): type is ReferenceSchemaType {\n  return isType(type, 'reference')\n}\n\nexport function isCrossDatasetReference(type: SchemaType): type is CrossDatasetReferenceSchemaType {\n  return isType(type, 'crossDatasetReference')\n}\n\nexport function isObjectField(maybeOjectField: unknown): boolean {\n  return (\n    typeof maybeOjectField === 'object' && maybeOjectField !== null && 'name' in maybeOjectField\n  )\n}\n\nexport function isCustomized(maybeCustomized: SchemaType): boolean {\n  const hasFieldsArray =\n    isObjectField(maybeCustomized) &&\n    !isType(maybeCustomized, 'reference') &&\n    !isType(maybeCustomized, 'crossDatasetReference') &&\n    'fields' in maybeCustomized &&\n    Array.isArray(maybeCustomized.fields)\n\n  if (!hasFieldsArray) {\n    return false\n  }\n\n  const fields = getCustomFields(maybeCustomized)\n  return !!fields.length\n}\n\nexport function isType(schemaType: SchemaType, typeName: string): boolean {\n  if (schemaType.name === typeName) {\n    return true\n  }\n  if (!schemaType.type) {\n    return false\n  }\n  return isType(schemaType.type, typeName)\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && typeof value === 'object'\n}\n\nexport function isPrimitive(value: unknown): value is string | boolean | number {\n  return isString(value) || isBoolean(value) || isNumber(value)\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'boolean'\n}\n\nfunction isBoolean(value: unknown): value is boolean {\n  return typeof value === 'number'\n}\n","import startCase from 'lodash/startCase'\nimport {\n  type ArraySchemaType,\n  type BlockDefinition,\n  type BooleanSchemaType,\n  ConcreteRuleClass,\n  createSchema,\n  type CrossDatasetReferenceSchemaType,\n  type FileSchemaType,\n  type MultiFieldSet,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type RuleSpec,\n  type Schema,\n  type SchemaType,\n  type SchemaValidationValue,\n  type SpanSchemaType,\n  type StringSchemaType,\n  type Workspace,\n} from 'sanity'\n\nimport {\n  getCustomFields,\n  isCrossDatasetReference,\n  isCustomized,\n  isDefined,\n  isPrimitive,\n  isRecord,\n  isReference,\n  isString,\n  isType,\n} from './manifestTypeHelpers'\nimport {\n  type CreateWorkspaceManifest,\n  type ManifestField,\n  type ManifestFieldset,\n  type ManifestSchemaType,\n  type ManifestSerializable,\n  type ManifestTitledValue,\n  type ManifestValidationGroup,\n  type ManifestValidationRule,\n} from './manifestTypes'\n\ninterface Context {\n  schema: Schema\n}\n\ntype SchemaTypeKey =\n  | keyof ArraySchemaType\n  | keyof BooleanSchemaType\n  | keyof FileSchemaType\n  | keyof NumberSchemaType\n  | keyof ObjectSchemaType\n  | keyof StringSchemaType\n  | keyof ReferenceSchemaType\n  | keyof BlockDefinition\n  | 'group' // we strip this from fields\n\ntype Validation = {validation: ManifestValidationGroup[]} | Record<string, never>\ntype ObjectFields = {fields: ManifestField[]} | Record<string, never>\ntype SerializableProp = ManifestSerializable | ManifestSerializable[] | undefined\ntype ManifestValidationFlag = ManifestValidationRule['flag']\ntype ValidationRuleTransformer = (rule: RuleSpec) => ManifestValidationRule | undefined\n\nconst MAX_CUSTOM_PROPERTY_DEPTH = 5\nconst INLINE_TYPES = ['document', 'object', 'image', 'file']\n\nexport function extractCreateWorkspaceManifest(workspace: Workspace): CreateWorkspaceManifest {\n  const serializedSchema = extractManifestSchemaTypes(workspace.schema)\n\n  return {\n    name: workspace.name,\n    title: workspace.title,\n    subtitle: workspace.subtitle,\n    basePath: workspace.basePath,\n    dataset: workspace.dataset,\n    schema: serializedSchema,\n  }\n}\n\n/**\n * Extracts all serializable properties from userland schema types,\n * so they best-effort can be used as definitions for Schema.compile\n. */\nexport function extractManifestSchemaTypes(schema: Schema): ManifestSchemaType[] {\n  const typeNames = schema.getTypeNames()\n  const context = {schema}\n\n  const studioDefaultTypeNames = createSchema({name: 'default', types: []}).getTypeNames()\n\n  return typeNames\n    .filter((typeName) => !studioDefaultTypeNames.includes(typeName))\n    .map((typeName) => schema.get(typeName))\n    .filter((type): type is SchemaType => typeof type !== 'undefined')\n    .map((type) => transformType(type, context))\n}\n\nfunction transformCommonTypeFields(\n  type: SchemaType & {fieldset?: string},\n  typeName: string,\n  context: Context,\n): Omit<ManifestSchemaType, 'name' | 'title' | 'type'> {\n  const arrayProps =\n    typeName === 'array' && type.jsonType === 'array' ? transformArrayMember(type, context) : {}\n\n  const referenceProps = isReference(type) ? transformReference(type) : {}\n  const crossDatasetRefProps = isCrossDatasetReference(type)\n    ? transformCrossDatasetReference(type)\n    : {}\n\n  const objectFields: ObjectFields =\n    type.jsonType === 'object' && type.type && INLINE_TYPES.includes(typeName) && isCustomized(type)\n      ? {\n          fields: getCustomFields(type).map((objectField) => transformField(objectField, context)),\n        }\n      : {}\n\n  return {\n    ...retainCustomTypeProps(type),\n    ...transformValidation(type.validation),\n    ...ensureString('description', type.description),\n    ...objectFields,\n    ...arrayProps,\n    ...referenceProps,\n    ...crossDatasetRefProps,\n    ...ensureConditional('readOnly', type.readOnly),\n    ...ensureConditional('hidden', type.hidden),\n    ...transformFieldsets(type),\n    // fieldset prop gets instrumented via getCustomFields\n    ...ensureString('fieldset', type.fieldset),\n    ...transformBlockType(type, context),\n  }\n}\n\nfunction transformFieldsets(\n  type: SchemaType,\n): {fieldsets: ManifestFieldset[]} | Record<string, never> {\n  if (type.jsonType !== 'object') {\n    return {}\n  }\n  const fieldsets = type.fieldsets\n    ?.filter((fs): fs is MultiFieldSet => !fs.single)\n    .map((fs) => {\n      const options = isRecord(fs.options) ? {options: retainSerializableProps(fs.options)} : {}\n      return {\n        name: fs.name,\n        ...ensureCustomTitle(fs.name, fs.title),\n        ...ensureString('description', fs.description),\n        ...ensureConditional('readOnly', fs.readOnly),\n        ...ensureConditional('hidden', fs.hidden),\n        ...options,\n      }\n    })\n\n  return fieldsets?.length ? {fieldsets} : {}\n}\n\nfunction transformType(type: SchemaType, context: Context): ManifestSchemaType {\n  const typeName = type.type ? type.type.name : type.jsonType\n\n  return {\n    ...transformCommonTypeFields(type, typeName, context),\n    name: type.name,\n    type: typeName,\n    ...ensureCustomTitle(type.name, type.title),\n  }\n}\n\nfunction retainCustomTypeProps(type: SchemaType): Record<string, SerializableProp> {\n  const manuallySerializedFields: SchemaTypeKey[] = [\n    //explicitly added\n    'name',\n    'title',\n    'description',\n    'readOnly',\n    'hidden',\n    'validation',\n    'fieldsets',\n    'fields',\n    'to',\n    'of',\n    // not serialized\n    'type',\n    'jsonType',\n    '__experimental_actions',\n    '__experimental_formPreviewTitle',\n    '__experimental_omnisearch_visibility',\n    '__experimental_search',\n    'components',\n    'icon',\n    'orderings',\n    'preview',\n    'groups',\n    //only exists on fields\n    'group',\n    // we know about these, but let them be generically handled\n    // deprecated\n    // rows (from text)\n    // initialValue\n    // options\n    // crossDatasetReference props\n  ]\n  const typeWithoutManuallyHandledFields = Object.fromEntries(\n    Object.entries(type).filter(\n      ([key]) => !manuallySerializedFields.includes(key as unknown as SchemaTypeKey),\n    ),\n  )\n  return retainSerializableProps(typeWithoutManuallyHandledFields) as Record<\n    string,\n    SerializableProp\n  >\n}\n\nfunction retainSerializableProps(maybeSerializable: unknown, depth = 0): SerializableProp {\n  if (depth > MAX_CUSTOM_PROPERTY_DEPTH) {\n    return undefined\n  }\n\n  if (!isDefined(maybeSerializable)) {\n    return undefined\n  }\n\n  if (isPrimitive(maybeSerializable)) {\n    // cull empty strings\n    if (maybeSerializable === '') {\n      return undefined\n    }\n    return maybeSerializable\n  }\n\n  // url-schemes ect..\n  if (maybeSerializable instanceof RegExp) {\n    return maybeSerializable.toString()\n  }\n\n  if (Array.isArray(maybeSerializable)) {\n    const arrayItems = maybeSerializable\n      .map((item) => retainSerializableProps(item, depth + 1))\n      .filter((item): item is ManifestSerializable => isDefined(item))\n    return arrayItems.length ? arrayItems : undefined\n  }\n\n  if (isRecord(maybeSerializable)) {\n    const serializableEntries = Object.entries(maybeSerializable)\n      .map(([key, value]) => {\n        return [key, retainSerializableProps(value, depth + 1)]\n      })\n      .filter(([, value]) => isDefined(value))\n    return serializableEntries.length ? Object.fromEntries(serializableEntries) : undefined\n  }\n\n  return undefined\n}\n\nfunction transformField(field: ObjectField & {fieldset?: string}, context: Context): ManifestField {\n  const fieldType = field.type\n  const typeNameExists = !!context.schema.get(fieldType.name)\n  const typeName = typeNameExists ? fieldType.name : (fieldType.type?.name ?? fieldType.name)\n  return {\n    ...transformCommonTypeFields(fieldType, typeName, context),\n    name: field.name,\n    type: typeName,\n    ...ensureCustomTitle(field.name, fieldType.title),\n    // this prop gets added synthetically via getCustomFields\n    ...ensureString('fieldset', field.fieldset),\n  }\n}\n\nfunction transformArrayMember(\n  arrayMember: ArraySchemaType,\n  context: Context,\n): Pick<ManifestField, 'of'> {\n  return {\n    of: arrayMember.of.map((type) => {\n      const typeNameExists = !!context.schema.get(type.name)\n      const typeName = typeNameExists ? type.name : (type.type?.name ?? type.name)\n      return {\n        ...transformCommonTypeFields(type, typeName, context),\n        type: typeName,\n        ...(typeName === type.name ? {} : {name: type.name}),\n        ...ensureCustomTitle(type.name, type.title),\n      }\n    }),\n  }\n}\n\nfunction transformReference(reference: ReferenceSchemaType): Pick<ManifestSchemaType, 'to'> {\n  return {\n    to: (reference.to ?? []).map((type) => {\n      return {\n        ...retainCustomTypeProps(type),\n        type: type.name,\n      }\n    }),\n  }\n}\n\nfunction transformCrossDatasetReference(\n  reference: CrossDatasetReferenceSchemaType,\n): Pick<ManifestSchemaType, 'to' | 'preview'> {\n  return {\n    to: (reference.to ?? []).map((crossDataset) => {\n      const preview = crossDataset.preview?.select\n        ? {preview: {select: crossDataset.preview.select}}\n        : {}\n      return {\n        type: crossDataset.type,\n        ...ensureCustomTitle(crossDataset.type, crossDataset.title),\n        ...preview,\n      }\n    }),\n  }\n}\n\nconst transformTypeValidationRule: ValidationRuleTransformer = (rule) => {\n  return {\n    ...rule,\n    constraint:\n      'constraint' in rule &&\n      (typeof rule.constraint === 'string'\n        ? rule.constraint.toLowerCase()\n        : retainSerializableProps(rule.constraint)),\n  }\n}\n\nconst validationRuleTransformers: Partial<\n  Record<ManifestValidationFlag, ValidationRuleTransformer>\n> = {\n  type: transformTypeValidationRule,\n}\n\nfunction transformValidation(validation: SchemaValidationValue): Validation {\n  const validationArray = (Array.isArray(validation) ? validation : [validation]).filter(\n    (value): value is Rule => typeof value === 'object' && '_type' in value,\n  )\n\n  // we dont want type in the output as that is implicitly given by the typedef itself an will only bloat the payload\n  const disallowedFlags = ['type']\n\n  // Validation rules that refer to other fields use symbols, which cannot be serialized. It would\n  // be possible to transform these to a serializable type, but we haven't implemented that for now.\n  const disallowedConstraintTypes: (symbol | unknown)[] = [ConcreteRuleClass.FIELD_REF]\n\n  const serializedValidation = validationArray\n    .map(({_rules, _message, _level}) => {\n      const message: Partial<Pick<ManifestValidationGroup, 'message'>> =\n        typeof _message === 'string' ? {message: _message} : {}\n\n      const serializedRules = _rules\n        .filter((rule) => {\n          if (!('constraint' in rule)) {\n            return false\n          }\n\n          const {flag, constraint} = rule\n\n          if (disallowedFlags.includes(flag)) {\n            return false\n          }\n\n          return !(\n            typeof constraint === 'object' &&\n            'type' in constraint &&\n            disallowedConstraintTypes.includes(constraint.type)\n          )\n        })\n        .reduce<ManifestValidationRule[]>((rules, rule) => {\n          const transformer: ValidationRuleTransformer =\n            validationRuleTransformers[rule.flag] ??\n            ((spec) => retainSerializableProps(spec) as ManifestValidationRule)\n\n          const transformedRule = transformer(rule)\n          if (!transformedRule) {\n            return rules\n          }\n          return [...rules, transformedRule]\n        }, [])\n\n      return {\n        rules: serializedRules,\n        level: _level,\n        ...message,\n      }\n    })\n    .filter((group) => !!group.rules.length)\n\n  return serializedValidation.length ? {validation: serializedValidation} : {}\n}\n\nfunction ensureCustomTitle(typeName: string, value: unknown) {\n  const titleObject = ensureString('title', value)\n\n  const defaultTitle = startCase(typeName)\n  // omit title if its the same as default, to reduce payload\n  if (titleObject.title === defaultTitle) {\n    return {}\n  }\n  return titleObject\n}\n\nfunction ensureString<Key extends string>(key: Key, value: unknown) {\n  if (typeof value === 'string') {\n    return {\n      [key]: value,\n    }\n  }\n\n  return {}\n}\n\nfunction ensureConditional<const Key extends string>(key: Key, value: unknown) {\n  if (typeof value === 'boolean') {\n    return {\n      [key]: value,\n    }\n  }\n\n  if (typeof value === 'function') {\n    return {\n      [key]: 'conditional',\n    }\n  }\n\n  return {}\n}\n\nexport function transformBlockType(\n  blockType: SchemaType,\n  context: Context,\n): Pick<ManifestSchemaType, 'marks' | 'lists' | 'styles' | 'of'> | Record<string, never> {\n  if (blockType.jsonType !== 'object' || !isType(blockType, 'block')) {\n    return {}\n  }\n\n  const childrenField = blockType.fields?.find((field) => field.name === 'children') as\n    | {type: ArraySchemaType}\n    | undefined\n\n  if (!childrenField) {\n    return {}\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    return {}\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    return {}\n  }\n  const inlineObjectTypes = (ofType.filter((memberType) => memberType.name !== 'span') ||\n    []) as ObjectSchemaType[]\n\n  return {\n    marks: {\n      annotations: (spanType as SpanSchemaType).annotations.map((t) => transformType(t, context)),\n      decorators: resolveEnabledDecorators(spanType),\n    },\n    lists: resolveEnabledListItems(blockType),\n    styles: resolveEnabledStyles(blockType),\n    of: inlineObjectTypes.map((t) => transformType(t, context)),\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType): ManifestTitledValue[] | undefined {\n  const styleField = blockType.fields?.find((btField) => btField.name === 'style')\n  return resolveTitleValueArray(styleField?.type?.options?.list)\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType): ManifestTitledValue[] | undefined {\n  return 'decorators' in spanType ? resolveTitleValueArray(spanType.decorators) : undefined\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType): ManifestTitledValue[] | undefined {\n  const listField = blockType.fields?.find((btField) => btField.name === 'listItem')\n  return resolveTitleValueArray(listField?.type?.options?.list)\n}\n\nfunction resolveTitleValueArray(possibleArray: unknown): ManifestTitledValue[] | undefined {\n  if (!possibleArray || !Array.isArray(possibleArray)) {\n    return undefined\n  }\n  const titledValues = possibleArray\n    .filter(\n      (d): d is {value: string; title?: string} => isRecord(d) && !!d.value && isString(d.value),\n    )\n    .map((item) => {\n      return {\n        value: item.value,\n        ...ensureString('title', item.title),\n      } satisfies ManifestTitledValue\n    })\n  if (!titledValues?.length) {\n    return undefined\n  }\n\n  return titledValues\n}\n","import {isMainThread, parentPort, workerData as _workerData} from 'node:worker_threads'\n\nimport {extractCreateWorkspaceManifest} from '../../manifest/extractWorkspaceManifest'\nimport {getStudioWorkspaces} from '../util/getStudioWorkspaces'\nimport {mockBrowserEnvironment} from '../util/mockBrowserEnvironment'\n\n/** @internal */\nexport interface ExtractManifestWorkerData {\n  workDir: string\n}\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nconst opts = _workerData as ExtractManifestWorkerData\n\nconst cleanup = mockBrowserEnvironment(opts.workDir)\n\nasync function main() {\n  try {\n    const workspaces = await getStudioWorkspaces({basePath: opts.workDir})\n\n    for (const workspace of workspaces) {\n      parentPort?.postMessage(extractCreateWorkspaceManifest(workspace))\n    }\n  } finally {\n    parentPort?.close()\n    cleanup()\n  }\n}\n\nmain()\n"],"names":["DEFAULT_IMAGE_FIELDS","DEFAULT_FILE_FIELDS","DEFAULT_GEOPOINT_FIELDS","DEFAULT_SLUG_FIELDS","getCustomFields","type","fields","fieldsets","flatMap","fs","single","field","map","fieldset","name","isType","filter","f","includes","isReference","isCrossDatasetReference","isObjectField","maybeOjectField","isCustomized","maybeCustomized","Array","isArray","length","schemaType","typeName","isDefined","value","isRecord","isPrimitive","isString","isBoolean","isNumber","MAX_CUSTOM_PROPERTY_DEPTH","INLINE_TYPES","extractCreateWorkspaceManifest","workspace","serializedSchema","extractManifestSchemaTypes","schema","title","subtitle","basePath","dataset","typeNames","getTypeNames","context","studioDefaultTypeNames","createSchema","types","get","transformType","transformCommonTypeFields","arrayProps","jsonType","transformArrayMember","referenceProps","transformReference","crossDatasetRefProps","transformCrossDatasetReference","objectFields","objectField","transformField","retainCustomTypeProps","transformValidation","validation","ensureString","description","ensureConditional","readOnly","hidden","transformFieldsets","transformBlockType","options","retainSerializableProps","ensureCustomTitle","manuallySerializedFields","typeWithoutManuallyHandledFields","Object","fromEntries","entries","key","maybeSerializable","depth","RegExp","toString","arrayItems","item","undefined","serializableEntries","fieldType","arrayMember","of","reference","to","crossDataset","preview","select","transformTypeValidationRule","rule","constraint","toLowerCase","validationRuleTransformers","validationArray","disallowedFlags","disallowedConstraintTypes","ConcreteRuleClass","FIELD_REF","serializedValidation","_rules","_message","_level","message","rules","flag","reduce","transformedRule","spec","level","group","titleObject","defaultTitle","startCase","blockType","childrenField","find","ofType","spanType","memberType","inlineObjectTypes","marks","annotations","t","decorators","resolveEnabledDecorators","lists","resolveEnabledListItems","styles","resolveEnabledStyles","styleField","btField","resolveTitleValueArray","list","listField","possibleArray","titledValues","d","isMainThread","parentPort","Error","opts","_workerData","cleanup","mockBrowserEnvironment","workDir","main","workspaces","getStudioWorkspaces","postMessage","close"],"mappings":"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"}