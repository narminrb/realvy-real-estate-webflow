{"version":3,"file":"index.cjs","sources":["../../src/constants.ts","../../src/util/props.ts","../../src/useDocumentLocations.ts","../../src/i18n/index.ts","../../src/PresentationContext.ts","../../src/usePresentationTool.ts","../../src/document/useCurrentPresentationToolName.ts","../../src/document/LocationsBanner.tsx","../../src/document/PresentationDocumentContext.ts","../../src/document/PresentationDocumentHeader.tsx","../../src/document/PresentationDocumentProvider.tsx","../../src/fieldActions/openInStructure.ts","../../src/getIntentState.ts","../../src/PresentationSpinner.tsx","../../src/router.ts","../../src/plugin.tsx","../../src/PresentationNavigateContext.ts","../../src/usePresentationNavigate.ts","../../src/PresentationParamsContext.ts","../../src/usePresentationParams.ts","../../src/overlays/SharedStateContext.tsx","../../src/overlays/useSharedState.ts","../../../../node_modules/.pnpm/valibot@0.31.1/node_modules/valibot/dist/index.js","../../src/reducers/presentationReducer.ts"],"sourcesContent":["import {ComposeIcon} from '@sanity/icons'\n\nexport const DEFAULT_TOOL_ICON = ComposeIcon\nexport const DEFAULT_TOOL_NAME = 'presentation'\nexport const DEFAULT_TOOL_TITLE = 'Presentation'\n\n// @todo import from core sanity package\nexport const COMMENTS_INSPECTOR_NAME = 'sanity/structure/comments'\n\nexport const EDIT_INTENT_MODE = 'presentation'\n\n// How long we wait until an iframe is loaded until we consider it to be slow and possibly failed\nexport const MAX_TIME_TO_OVERLAYS_CONNECTION = 3_000 // ms\n\n// The API version to use when using `@sanity/client`\nexport const API_VERSION = '2023-10-16'\n\n// Heartbeats shouldn't fire on intervals that are so short it causes performance issues\nexport const MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = 1000 // ms\n\n// Batch size for fetching documents building up the cache\nexport const LIVE_QUERY_CACHE_BATCH_SIZE = 100\n\n// Total cache size for documents that are live queried\nexport const LIVE_QUERY_CACHE_SIZE = 2048\n\n// The interval at which we check if existing popups have been closed\nexport const POPUP_CHECK_INTERVAL = 1000 // ms\n\ndeclare global {\n  const PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS: unknown\n}\n\n// Feature flag that uses the new Live Draft Content API instead of the Listen API + Mendoza events\nexport const LIVE_DRAFT_EVENTS_ENABLED =\n  typeof PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'string'\n    ? PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'true'\n    : // @ts-expect-error: env vars are not typed\n      process.env.SANITY_STUDIO_PRESENTATION_ENABLE_LIVE_DRAFT_EVENTS === 'true'\n","import {\n  combineLatest,\n  from,\n  isObservable,\n  map,\n  mergeAll,\n  Observable,\n  of,\n  scan,\n  switchMap,\n} from 'rxjs'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Props<K extends keyof any, T> = {\n  [P in K]: T | Observable<T>\n}\n\nfunction keysOf<T extends object>(value: T) {\n  return Object.keys(value) as (keyof T)[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setKey(source: Record<string, unknown>, key: any, value: unknown) {\n  return {\n    ...source,\n    [key]: value,\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function props<K extends keyof any, T>(options: {wait?: boolean} = {}) {\n  return (source: Observable<Props<K, T>>): Observable<Record<string, unknown>> => {\n    return new Observable<Props<K, T>>((observer) => source.subscribe(observer)).pipe(\n      switchMap((object) => {\n        const keyObservables = keysOf(object).map((key) => {\n          const value = object[key]\n          return isObservable(value) ? from(value).pipe(map((val) => [key, val])) : of([key, value])\n        })\n\n        return options.wait\n          ? combineLatest(keyObservables).pipe(\n              map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {})),\n            )\n          : from(keyObservables).pipe(\n              mergeAll(),\n              scan((acc, [key, value]) => setKey(acc, key, value), {}),\n            )\n      }),\n    )\n  }\n}\n","import get from 'lodash.get'\nimport {useEffect, useMemo, useState} from 'react'\nimport {isObservable, map, Observable, of, switchMap} from 'rxjs'\nimport {\n  isRecord,\n  isReference,\n  useDocumentStore,\n  type DocumentStore,\n  type Previewable,\n  type SanityDocument,\n} from './internals'\nimport type {\n  DocumentLocationResolver,\n  DocumentLocationResolverObject,\n  DocumentLocationResolvers,\n  DocumentLocationsState,\n  DocumentLocationsStatus,\n} from './types'\nimport {props} from './util/props'\n\nconst INITIAL_STATE: DocumentLocationsState = {locations: []}\n\nfunction getDocumentId(value: Previewable) {\n  if (isReference(value)) {\n    return value._ref\n  }\n  return '_id' in value ? value._id : undefined\n}\n\nfunction cleanPreviewable(id: string | undefined, previewable: Previewable) {\n  const clean: Record<string, unknown> = id ? {...previewable, _id: id} : {...previewable}\n\n  if (clean['_type'] === 'reference') {\n    delete clean['_type']\n    delete clean['_ref']\n    delete clean['_weak']\n    delete clean['_dataset']\n    delete clean['_projectId']\n    delete clean['_strengthenOnPublish']\n  }\n\n  return clean\n}\n\nfunction listen(id: string, fields: string[], store: DocumentStore) {\n  const projection = fields.join(', ')\n  const query = `*[_id==$id][0]{${projection}}`\n  const params = {id}\n  return store.listenQuery(query, params, {\n    perspective: 'previewDrafts',\n  }) as Observable<SanityDocument | null>\n}\n\nfunction observeDocument(\n  value: Previewable | null,\n  paths: string[][],\n  store: DocumentStore,\n): Observable<Record<string, unknown> | null> {\n  if (!value || typeof value !== 'object') {\n    return of(value)\n  }\n\n  const id = getDocumentId(value)\n  const currentValue = cleanPreviewable(id, value)\n\n  const headlessPaths = paths.filter((path) => !(path[0] in currentValue))\n\n  if (id && headlessPaths.length) {\n    const fields = [...new Set(headlessPaths.map((path: string[]) => path[0]))]\n    return listen(id, fields, store).pipe(\n      switchMap((snapshot) => {\n        if (snapshot) {\n          return observeDocument(snapshot, paths, store)\n        }\n        return of(null)\n      }),\n    )\n  }\n\n  const leads: Record<string, string[][]> = {}\n  paths.forEach((path) => {\n    const [head, ...tail] = path\n    if (!leads[head]) {\n      leads[head] = []\n    }\n    leads[head].push(tail)\n  })\n  const next = Object.keys(leads).reduce((res: Record<string, unknown>, head) => {\n    const tails = leads[head].filter((tail) => tail.length > 0)\n    if (tails.length === 0) {\n      res[head] = isRecord(value) ? (value as Record<string, unknown>)[head] : undefined\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      res[head] = observeDocument((value as any)[head], tails, store)\n    }\n    return res\n  }, currentValue)\n\n  return of(next).pipe(props({wait: true}))\n}\n\nfunction observeForLocations(\n  documentId: string,\n  resolver: DocumentLocationResolverObject<string>,\n  documentStore: DocumentStore,\n) {\n  const {select} = resolver\n  const paths = Object.values(select).map((value) => String(value).split('.')) || []\n  const doc = {_type: 'reference', _ref: documentId}\n  return observeDocument(doc, paths, documentStore).pipe(\n    map((doc) => {\n      return Object.keys(select).reduce<Record<string, unknown>>((acc, key) => {\n        acc[key] = get(doc, select[key])\n        return acc\n      }, {})\n    }),\n    map(resolver.resolve),\n  )\n}\n\nexport function useDocumentLocations(props: {\n  id: string\n  resolvers?: DocumentLocationResolver | DocumentLocationResolvers\n  type: string\n}): {\n  state: DocumentLocationsState\n  status: DocumentLocationsStatus\n} {\n  const {id, resolvers, type} = props\n  const documentStore = useDocumentStore()\n  const [locationsState, setLocationsState] = useState<DocumentLocationsState>(INITIAL_STATE)\n\n  const resolver = resolvers && (typeof resolvers === 'function' ? resolvers : resolvers[type])\n\n  const [locationsStatus, setLocationsStatus] = useState<DocumentLocationsStatus>(\n    resolver ? 'resolving' : 'empty',\n  )\n\n  const result = useMemo(() => {\n    if (!resolver) return undefined\n\n    // Original/advanced resolver which requires explicit use of Observables\n    if (typeof resolver === 'function') {\n      const params = {id, type}\n      const context = {documentStore}\n      const _result = resolver(params, context)\n      return isObservable(_result) ? _result : of(_result)\n    }\n\n    // Simplified resolver pattern which abstracts away Observable logic\n    if ('select' in resolver && 'resolve' in resolver) {\n      return observeForLocations(id, resolver, documentStore)\n    }\n\n    // Resolver is explicitly provided state\n    return of(resolver)\n  }, [documentStore, id, resolver, type])\n\n  useEffect(() => {\n    const sub = result?.subscribe((state) => {\n      setLocationsState(state || INITIAL_STATE)\n      setLocationsStatus(state ? 'resolved' : 'empty')\n    })\n\n    return () => sub?.unsubscribe()\n  }, [result])\n\n  return {\n    state: locationsState,\n    status: locationsStatus,\n  }\n}\n","import {defineLocaleResourceBundle} from 'sanity'\n\n/**\n * The locale namespace for the presentation tool\n *\n * @public\n */\nexport const presentationLocaleNamespace = 'presentation' as const\n\n/**\n * The default locale bundle for the presentation tool, which is US English.\n *\n * @internal\n */\nexport const presentationUsEnglishLocaleBundle = defineLocaleResourceBundle({\n  locale: 'en-US',\n  namespace: presentationLocaleNamespace,\n  resources: () => import('./resources'),\n})\n","import {createContext} from 'react'\nimport type {\n  PresentationNavigate,\n  PresentationParams,\n  PresentationSearchParams,\n  StructureDocumentPaneParams,\n} from './types'\n\nexport interface PresentationContextValue {\n  devMode: boolean\n  name: string\n  navigate: PresentationNavigate\n  params: PresentationParams\n  structureParams: StructureDocumentPaneParams\n  searchParams: PresentationSearchParams\n}\n\nexport const PresentationContext = createContext<PresentationContextValue | null>(null)\n","import {useContext} from 'react'\nimport {PresentationContext, type PresentationContextValue} from './PresentationContext'\n\nexport function usePresentationTool(throwOnMissingContext?: true): PresentationContextValue\nexport function usePresentationTool(throwOnMissingContext: false): PresentationContextValue | null\nexport function usePresentationTool(throwOnMissingContext = true): PresentationContextValue | null {\n  const presentation = useContext(PresentationContext)\n\n  if (throwOnMissingContext && !presentation) {\n    throw new Error('Presentation context is missing')\n  }\n\n  return presentation\n}\n","import {usePresentationTool} from '../usePresentationTool'\n\nexport function useCurrentPresentationToolName(): string | undefined {\n  return usePresentationTool(false)?.name ?? undefined\n}\n","import {\n  ChevronRightIcon,\n  DesktopIcon,\n  ErrorOutlineIcon,\n  InfoOutlineIcon,\n  WarningOutlineIcon,\n} from '@sanity/icons'\nimport {Box, Card, Flex, Spinner, Stack, Text} from '@sanity/ui'\nimport {\n  createElement,\n  useCallback,\n  useContext,\n  useState,\n  type ComponentType,\n  type ReactNode,\n} from 'react'\nimport {useTranslation, type ObjectSchemaType} from 'sanity'\nimport {useIntentLink} from 'sanity/router'\nimport {DEFAULT_TOOL_NAME, DEFAULT_TOOL_TITLE} from '../constants'\nimport {presentationLocaleNamespace} from '../i18n'\nimport {PresentationContext} from '../PresentationContext'\nimport type {DocumentLocation, DocumentLocationsState, PresentationPluginOptions} from '../types'\nimport {useCurrentPresentationToolName} from './useCurrentPresentationToolName'\n\nconst TONE_ICONS: Record<'positive' | 'caution' | 'critical', ComponentType> = {\n  positive: InfoOutlineIcon,\n  caution: WarningOutlineIcon,\n  critical: ErrorOutlineIcon,\n}\n\nexport function LocationsBanner(props: {\n  documentId: string\n  isResolving: boolean\n  options: PresentationPluginOptions\n  schemaType: ObjectSchemaType\n  showPresentationTitle: boolean\n  state: DocumentLocationsState\n}): ReactNode {\n  const {documentId, isResolving, options, schemaType, showPresentationTitle} = props\n  const {locations, message, tone} = props.state\n  const len = locations?.length || 0\n\n  const {t} = useTranslation(presentationLocaleNamespace)\n  const presentation = useContext(PresentationContext)\n  const [expanded, setExpanded] = useState(false)\n  const toggle = useCallback(() => {\n    if (!len) return\n    setExpanded((v) => !v)\n  }, [len])\n\n  const title = isResolving\n    ? t('locations-banner.resolving.text')\n    : message || t('locations-banner.locations-count', {count: len})\n\n  return (\n    <Card padding={1} radius={2} border tone={tone}>\n      <div style={{margin: -1}}>\n        {!locations && (\n          <Flex align=\"flex-start\" gap={3} padding={3}>\n            {tone && (\n              <Box flex=\"none\">\n                <Text size={1}>{createElement(TONE_ICONS[tone])}</Text>\n              </Box>\n            )}\n            <Box flex={1}>\n              <Text size={1} weight=\"medium\">\n                {showPresentationTitle && <>{options.title || DEFAULT_TOOL_TITLE} &middot; </>}\n                {title}\n              </Text>\n            </Box>\n          </Flex>\n        )}\n        {locations && (\n          <>\n            <Card\n              as={len ? 'button' : undefined}\n              onClick={toggle}\n              padding={3}\n              radius={1}\n              tone=\"inherit\"\n            >\n              <Flex gap={3}>\n                <Box flex=\"none\">\n                  {isResolving ? (\n                    <Spinner size={1} />\n                  ) : (\n                    <Text size={1}>\n                      {len === 0 ? (\n                        <InfoOutlineIcon />\n                      ) : (\n                        <ChevronRightIcon\n                          style={{\n                            transform: `rotate(${expanded ? '90deg' : 0})`,\n                            transition: 'transform 100ms ease-in-out',\n                          }}\n                        />\n                      )}\n                    </Text>\n                  )}\n                </Box>\n                <Box flex={1}>\n                  <Text size={1} weight=\"medium\">\n                    {showPresentationTitle && <>{options.title || DEFAULT_TOOL_TITLE} &middot; </>}\n                    {title}\n                  </Text>\n                </Box>\n              </Flex>\n            </Card>\n            <Stack hidden={!expanded} marginTop={1} space={1}>\n              {locations.map((l, index) => (\n                <LocationItem\n                  active={\n                    (options.name || DEFAULT_TOOL_NAME) === presentation?.name &&\n                    l.href === presentation?.params.preview\n                  }\n                  documentId={documentId}\n                  documentType={schemaType.name}\n                  key={index}\n                  node={l}\n                  toolName={options.name || DEFAULT_TOOL_NAME}\n                />\n              ))}\n            </Stack>\n          </>\n        )}\n      </div>\n    </Card>\n  )\n}\n\nfunction LocationItem(props: {\n  active: boolean\n  documentId: string\n  documentType: string\n  node: DocumentLocation\n  toolName: string\n}) {\n  const {documentId, documentType, node, active, toolName} = props\n  const presentation = useContext(PresentationContext)\n  const currentPresentationToolName = useCurrentPresentationToolName()\n  const isCurrentTool = toolName === currentPresentationToolName\n  const navigate = presentation?.navigate\n\n  const presentationLinkProps = useIntentLink({\n    intent: 'edit',\n    params: {\n      id: documentId,\n      type: documentType,\n      mode: 'presentation',\n      presentation: toolName,\n      ...presentation?.structureParams,\n      preview: node.href,\n    },\n  })\n\n  const handleCurrentToolClick = useCallback(() => {\n    navigate?.({}, {preview: node.href})\n  }, [node.href, navigate])\n\n  return (\n    <Card\n      {...(isCurrentTool ? {} : presentationLinkProps)}\n      as=\"a\"\n      key={node.href}\n      onClick={isCurrentTool ? handleCurrentToolClick : presentationLinkProps.onClick}\n      padding={3}\n      radius={1}\n      pressed={active}\n      tone=\"inherit\"\n    >\n      <Flex gap={3}>\n        <Box flex=\"none\">\n          <Text size={1}>\n            <DesktopIcon />\n          </Text>\n        </Box>\n        <Stack flex={1} space={2}>\n          <Text size={1} weight=\"medium\">\n            {node.title}\n          </Text>\n          <Text muted size={1} textOverflow=\"ellipsis\">\n            {node.href}\n          </Text>\n        </Stack>\n      </Flex>\n    </Card>\n  )\n}\n","import {createContext} from 'react'\nimport type {PresentationDocumentContextValue} from './types'\n\nexport const PresentationDocumentContext = createContext<PresentationDocumentContextValue | null>(\n  null,\n)\n","import {rem, Stack} from '@sanity/ui'\nimport {useContext, type ReactNode} from 'react'\nimport {type ObjectSchemaType} from 'sanity'\nimport {styled} from 'styled-components'\nimport {type PublishedId} from '../internals'\nimport type {PresentationPluginOptions} from '../types'\nimport {useDocumentLocations} from '../useDocumentLocations'\nimport {LocationsBanner} from './LocationsBanner'\nimport {PresentationDocumentContext} from './PresentationDocumentContext'\n\nconst LocationStack = styled(Stack)`\n  min-height: ${rem(42)};\n\n  & + &:empty {\n    display: none;\n  }\n`\n\nexport function PresentationDocumentHeader(props: {\n  documentId: PublishedId\n  options: PresentationPluginOptions\n  schemaType: ObjectSchemaType\n}): ReactNode {\n  const {documentId, options, schemaType} = props\n\n  const context = useContext(PresentationDocumentContext)\n  const {state, status} = useDocumentLocations({\n    id: documentId,\n    resolvers: options.resolve?.locations || options.locate,\n    type: schemaType.name,\n  })\n\n  if ((context && context.options[0] !== options) || status === 'empty') {\n    return null\n  }\n\n  const contextOptions = context?.options || []\n\n  return (\n    <LocationStack marginBottom={5} space={5}>\n      <Stack space={2}>\n        {contextOptions.map((options, idx) => (\n          <LocationsBanner\n            documentId={documentId}\n            isResolving={status === 'resolving'}\n            key={idx}\n            options={options}\n            schemaType={schemaType}\n            showPresentationTitle={contextOptions.length > 1}\n            state={state}\n          />\n        ))}\n      </Stack>\n    </LocationStack>\n  )\n}\n","import {\n  useCallback,\n  useContext,\n  useLayoutEffect,\n  useMemo,\n  useState,\n  type ReactElement,\n  type ReactNode,\n} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {PresentationPluginOptions} from '../types'\nimport {PresentationDocumentContext} from './PresentationDocumentContext'\nimport type {PresentationDocumentContextValue} from './types'\n\n/** @internal */\nexport function PresentationDocumentProvider(props: {\n  children?: ReactNode\n  options: PresentationPluginOptions\n}): ReactElement {\n  const {children, options} = props\n  const parent = useContext(PresentationDocumentContext)\n  const parentRegister = parent?.register\n\n  const [optionsArray, setOptionsArray] = useState<PresentationPluginOptions[]>(() => [])\n\n  const register = useCallback(\n    (options: PresentationPluginOptions) => {\n      if (parentRegister) {\n        return parentRegister(options)\n      }\n\n      setOptionsArray((prev) => [options].concat(prev))\n\n      return () => {\n        setOptionsArray((prev) => prev.filter((o) => o !== options))\n      }\n    },\n    [parentRegister],\n  )\n\n  const context: PresentationDocumentContextValue = useMemo(\n    () => ({\n      options: parent?.options || optionsArray,\n      register,\n    }),\n    [optionsArray, parent, register],\n  )\n\n  const registerEffectEvent = useEffectEvent((options: PresentationPluginOptions) =>\n    register(options),\n  )\n  useLayoutEffect(() => registerEffectEvent(options), [registerEffectEvent, options])\n\n  return (\n    <PresentationDocumentContext.Provider value={context}>\n      {children}\n    </PresentationDocumentContext.Provider>\n  )\n}\n","import {MasterDetailIcon} from '@sanity/icons'\nimport {useContext, useMemo} from 'react'\nimport {type Tool} from 'sanity'\nimport {useRouter} from 'sanity/router'\nimport {\n  defineDocumentFieldAction,\n  isRecord,\n  pathToString,\n  useWorkspace,\n  type DocumentFieldActionItem,\n} from '../internals'\nimport {PresentationContext} from '../PresentationContext'\n\nexport const openInStructure = defineDocumentFieldAction({\n  name: 'presentation/openInStructure',\n  useAction({documentId, documentType, path}) {\n    const workspace = useWorkspace()\n    const {navigateIntent} = useRouter()\n    const presentation = useContext(PresentationContext)\n\n    const defaultStructureTool = useMemo(\n      () => findStructureTool(workspace.tools, documentId, documentType),\n      [documentId, documentType, workspace.tools],\n    )\n\n    return {\n      type: 'action',\n      hidden: !presentation || path.length > 0 || !defaultStructureTool,\n      icon: defaultStructureTool?.icon || MasterDetailIcon,\n      title: `Open in ${defaultStructureTool?.title || 'Structure'}`,\n      onAction() {\n        navigateIntent('edit', {\n          id: documentId,\n          type: documentType,\n          mode: 'structure',\n          path: pathToString(path),\n        })\n      },\n      renderAsButton: true,\n    } satisfies DocumentFieldActionItem\n  },\n})\n\nfunction findStructureTool(\n  tools: Tool[],\n  documentId: string,\n  documentType: string,\n): Tool | undefined {\n  const results = tools.map((t) => {\n    const match = t.canHandleIntent?.(\n      'edit',\n      {\n        id: documentId,\n        type: documentType,\n        mode: 'structure',\n      },\n      {},\n    )\n\n    return {tool: t, match}\n  })\n\n  const modeMatches = results.filter((t) => isRecord(t.match) && t.match['mode'])\n\n  if (modeMatches.length > 0) {\n    return modeMatches[0].tool\n  }\n\n  const matches = results.filter((t) => t.match)\n\n  return matches[0]?.tool\n}\n","import {uuid} from '@sanity/uuid'\nimport {type RouterState, type SearchParam} from 'sanity/router'\nimport {encodeJsonParams, getPublishedId} from './internals'\nimport type {PresentationSearchParams, PresentationStateParams} from './types'\n\nconst preservedSearchParamKeys: Array<keyof PresentationSearchParams> = [\n  'preview',\n  'perspective',\n  'viewport',\n]\n\n/**\n * @internal\n */\nexport function getIntentState(\n  intent: string,\n  params: Record<string, string>,\n  routerState: RouterState | undefined,\n  payload: unknown,\n):\n  | (PresentationStateParams & {_searchParams: SearchParam[]})\n  | {intent: string; params: Record<string, string>; payload: unknown} {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {id, mode, path, presentation, type, ...searchParams} = params\n\n  const preservedSearchParams = (routerState?._searchParams || [])\n    // @todo Casting https://github.com/microsoft/TypeScript/issues/14520\n    .filter(([key]) => preservedSearchParamKeys.includes(key as keyof PresentationSearchParams))\n    .reduce((acc, [key, value]) => ({...acc, [key]: value}), {} as Record<string, string>)\n\n  const _searchParams = {\n    ...preservedSearchParams,\n    ...searchParams,\n  }\n\n  if (intent === 'edit' && id) {\n    _searchParams['preview'] =\n      _searchParams['preview'] || new URLSearchParams(window.location.search).get('preview') || '/'\n    return {\n      type: type || '*',\n      id: getPublishedId(id),\n      path,\n      _searchParams: Object.entries(_searchParams),\n    }\n  }\n\n  if (intent === 'create') {\n    _searchParams['preview'] =\n      _searchParams['preview'] || new URLSearchParams(window.location.search).get('preview') || '/'\n\n    if (payload && typeof payload === 'object') {\n      _searchParams['templateParams'] = encodeJsonParams(payload as Record<string, unknown>)\n    }\n\n    return {\n      type: type || '*',\n      id: id || uuid(),\n      _searchParams: Object.entries(_searchParams),\n    }\n  }\n  return {intent, params, payload}\n}\n","import {Flex, Spinner} from '@sanity/ui'\n\nexport function PresentationSpinner(): React.JSX.Element {\n  return (\n    <Flex align=\"center\" direction=\"column\" height=\"fill\" justify=\"center\" style={{width: '100%'}}>\n      <Spinner />\n    </Flex>\n  )\n}\n","import {route} from 'sanity/router'\n\nexport const router = route.create('/', {__unsafe_disableScopedSearchParams: true}, [\n  route.intents('/intent'),\n  route.create(':type', [route.create(':id', [route.create(':path')])]),\n])\n","import type {SanityDocument} from '@sanity/client'\nimport {lazy, Suspense} from 'react'\nimport {definePlugin, isDocumentSchemaType, type InputProps} from 'sanity'\nimport {DEFAULT_TOOL_ICON, DEFAULT_TOOL_NAME, EDIT_INTENT_MODE} from './constants'\nimport {PresentationDocumentHeader} from './document/PresentationDocumentHeader'\nimport {PresentationDocumentProvider} from './document/PresentationDocumentProvider'\nimport {openInStructure} from './fieldActions/openInStructure'\nimport {getIntentState} from './getIntentState'\nimport {presentationUsEnglishLocaleBundle} from './i18n'\nimport {getPublishedId} from './internals'\nimport {PresentationSpinner} from './PresentationSpinner'\nimport {router} from './router'\nimport type {\n  DocumentLocationResolverObject,\n  DocumentLocationsState,\n  DocumentResolver,\n  PresentationPluginOptions,\n} from './types'\n\nconst PresentationTool = lazy(() => import('./PresentationToolGrantsCheck'))\nconst BroadcastDisplayedDocument = lazy(() => import('./loader/BroadcastDisplayedDocument'))\n\n/**\n * Define locations for a given document type.\n * This function doesn't do anything itself, it is used to provide type information.\n * @param resolver - resolver that return locations for a document.\n * @public\n */\nexport function defineLocations<K extends string>(\n  resolver: DocumentLocationResolverObject<K> | DocumentLocationsState,\n): typeof resolver {\n  return resolver\n}\n\n/**\n * Define documents for a given location.\n * This function doesn't do anything itself, it is used to provide type information.\n * @param resolvers - resolvers that return documents.\n * @public\n */\nexport function defineDocuments(resolvers: DocumentResolver[]): typeof resolvers {\n  return resolvers\n}\n\nexport const presentationTool = definePlugin<PresentationPluginOptions>((options) => {\n  const toolName = options.name || DEFAULT_TOOL_NAME\n\n  if ('locate' in options) {\n    // eslint-disable-next-line no-console\n    console.warn('Presentation’s `locate` option is deprecated. Use `resolve.locations` instead.')\n  }\n\n  const hasLocationsResolver = !!(options.resolve?.locations || options.locate)\n\n  function PresentationDocumentInput(props: InputProps) {\n    const value = props.value as SanityDocument\n    const documentId = value?._id ? getPublishedId(value?._id) : undefined\n\n    if (isDocumentSchemaType(props.schemaType)) {\n      return (\n        <PresentationDocumentProvider options={options}>\n          {hasLocationsResolver && documentId && (\n            <PresentationDocumentHeader\n              documentId={documentId}\n              options={options}\n              schemaType={props.schemaType}\n            />\n          )}\n          <Suspense fallback={<PresentationSpinner />}>{props.renderDefault(props)}</Suspense>\n          <Suspense key=\"broadcast-displayed-document\">\n            <BroadcastDisplayedDocument key={documentId} value={value} />\n          </Suspense>\n        </PresentationDocumentProvider>\n      )\n    }\n\n    return props.renderDefault(props)\n  }\n\n  function canHandleCreateIntent(params: Record<string, unknown>) {\n    // We can't handle create intents without a `type` parameter\n    if (!('type' in params)) {\n      return false\n    }\n\n    if ('presentation' in params && params['presentation'] !== toolName) {\n      return false\n    }\n\n    return 'template' in params ? {template: true} : true\n  }\n\n  function canHandleEditIntent(params: Record<string, unknown>) {\n    // We can't handle edit intents without `type` or `id` parameters\n    if (!('type' in params) || !('id' in params)) {\n      return false\n    }\n\n    if ('presentation' in params && params['presentation'] !== toolName) {\n      return false\n    }\n\n    return 'mode' in params ? {mode: params['mode'] === EDIT_INTENT_MODE} : true\n  }\n\n  return {\n    i18n: {\n      bundles: [presentationUsEnglishLocaleBundle],\n    },\n    document: {\n      unstable_fieldActions: (prev) => {\n        return [\n          ...prev.filter((a) => a.name !== openInStructure.name), // prevent duplication\n          openInStructure,\n        ]\n      },\n    },\n\n    form: {\n      components: {\n        input: PresentationDocumentInput,\n      },\n    },\n\n    tools: [\n      {\n        icon: options.icon || DEFAULT_TOOL_ICON,\n        name: toolName,\n        title: options.title,\n        component: PresentationTool,\n        options,\n        canHandleIntent(intent, params) {\n          if (intent === 'create') return canHandleCreateIntent(params)\n          if (intent === 'edit') return canHandleEditIntent(params)\n          return false\n        },\n        getIntentState,\n        router,\n      },\n    ],\n  }\n})\n","import {createContext} from 'react'\n\nexport type PresentationNavigateContextValue = (\n  preview: string | undefined,\n  document?: {type: string; id: string},\n) => void\n\nexport const PresentationNavigateContext = createContext<PresentationNavigateContextValue | null>(\n  null,\n)\n","import {useContext} from 'react'\nimport {\n  PresentationNavigateContext,\n  type PresentationNavigateContextValue,\n} from './PresentationNavigateContext'\n\nexport function usePresentationNavigate(): PresentationNavigateContextValue {\n  const navigate = useContext(PresentationNavigateContext)\n\n  if (!navigate) {\n    throw new Error('Presentation navigate context is missing')\n  }\n\n  return navigate\n}\n\nexport type {PresentationNavigateContextValue}\n","import {createContext} from 'react'\nimport type {PresentationParams} from './types'\n\nexport const PresentationParamsContext = createContext<PresentationParams | null>(null)\n","import {useContext} from 'react'\nimport {PresentationParamsContext} from './PresentationParamsContext'\nimport type {PresentationParams} from './types'\n\n/** @public */\nexport function usePresentationParams(throwOnMissingContext?: true): PresentationParams\n/** @public */\nexport function usePresentationParams(throwOnMissingContext: false): PresentationParams | null\n/** @public */\nexport function usePresentationParams(throwOnMissingContext = true): PresentationParams | null {\n  const params = useContext(PresentationParamsContext)\n\n  if (throwOnMissingContext && !params) {\n    throw new Error('Presentation params context is missing')\n  }\n\n  return params\n}\n","import type {Serializable} from '@repo/visual-editing-helpers'\nimport {createContext} from 'react'\n\nexport interface SharedStateContextValue {\n  removeValue: (key: string) => void\n  setValue: (key: string, value: Serializable) => void\n}\n\nexport const SharedStateContext = createContext<SharedStateContextValue | null>(null)\n","import type {Serializable} from '@repo/visual-editing-helpers'\nimport {useContext, useEffect} from 'react'\nimport {SharedStateContext} from './SharedStateContext'\n\nexport const useSharedState = (key: string, value: Serializable): undefined => {\n  const context = useContext(SharedStateContext)\n\n  if (!context) {\n    throw new Error('Preview Snapshots context is missing')\n  }\n\n  const {setValue} = context\n\n  useEffect(() => {\n    setValue(key, value)\n  }, [key, value, setValue])\n\n  return undefined\n}\n","// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config2?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly,\n    skipPipe: config2.skipPipe\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = (\n    // @ts-expect-error\n    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)\n  );\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isAllowedObjectKey/_isAllowedObjectKey.ts\nfunction _isAllowedObjectKey(key) {\n  return key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (\"key\" in item && (typeof item.key === \"string\" || typeof item.key === \"number\")) {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/every/every.ts\nfunction every(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every\",\n    reference: every,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/some/some.ts\nfunction some(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some\",\n    reference: some,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    action,\n    _run(dataset) {\n      dataset.value = action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    action,\n    async _run(dataset) {\n      dataset.value = await action(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date && !isNaN(dataset.value.getTime())) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isAllowedObjectKey(key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isAllowedObjectKey(key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isAllowedObjectKey(entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isAllowedObjectKey(key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"record\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key: items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(items.length).map(async (value2, key) => {\n              return [\n                key + items.length,\n                value2,\n                await rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        dataset = await pipe2[index]._run(dataset, config2);\n        const nextAction = pipe2[index + 1];\n        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!\n        nextAction?.kind === \"schema\" || nextAction?.kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isAllowedObjectKey,\n  _isLuhnAlgo,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_,\n  every,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  readonly,\n  record,\n  recordAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  some,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_\n};\n","import type {Dispatch, Reducer} from 'react'\nimport {boolean, fallback, object, parse, picklist} from 'valibot'\n\nexport interface PresentationState {\n  mainDocument: boolean\n  iframe: {\n    status: 'loading' | 'loaded' | 'refreshing' | 'reloading'\n  }\n  visualEditing: {\n    overlaysEnabled: boolean\n  }\n}\n\nexport const ACTION_IFRAME_LOADED = 'ACTION_IFRAME_LOADED'\nexport const ACTION_IFRAME_REFRESH = 'ACTION_IFRAME_REFRESH'\nexport const ACTION_IFRAME_RELOAD = 'ACTION_IFRAME_RELOAD'\nexport const ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = 'ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE'\n\nexport interface IframeLoadedAction {\n  type: typeof ACTION_IFRAME_LOADED\n}\nexport interface IframeRefreshAction {\n  type: typeof ACTION_IFRAME_REFRESH\n}\nexport interface IframeReloadAction {\n  type: typeof ACTION_IFRAME_RELOAD\n}\nexport interface VisualEditingOverlaysToggleAction {\n  type: typeof ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE\n  enabled: boolean\n}\n\nexport type PresentationAction =\n  | IframeLoadedAction\n  | IframeRefreshAction\n  | IframeReloadAction\n  | VisualEditingOverlaysToggleAction\n\nexport const presentationReducer: Reducer<\n  Readonly<PresentationState>,\n  Readonly<PresentationAction>\n> = (state, action) => {\n  switch (action.type) {\n    case ACTION_IFRAME_LOADED:\n      return state.iframe.status === 'loaded'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'loaded',\n            },\n          }\n    case ACTION_IFRAME_REFRESH:\n      return state.iframe.status === 'refreshing'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'refreshing',\n            },\n          }\n    case ACTION_IFRAME_RELOAD:\n      return state.iframe.status === 'reloading'\n        ? state\n        : {\n            ...state,\n            iframe: {\n              ...state.iframe,\n              status: 'reloading',\n            },\n          }\n    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:\n      return toggleVisualEditingOverlays(state, action)\n    default:\n      return state\n  }\n}\n\nconst toggleVisualEditingOverlays: Reducer<\n  Readonly<PresentationState>,\n  Readonly<VisualEditingOverlaysToggleAction>\n> = (state, action) => {\n  if (state.visualEditing.overlaysEnabled === action.enabled) return state\n  return {\n    ...state,\n    visualEditing: {\n      ...state.visualEditing,\n      overlaysEnabled: action.enabled,\n    },\n  }\n}\n\nconst mainDocumentSchema = fallback(boolean(), false)\n\nconst iframeStatusSchema = picklist(['loading', 'loaded', 'refreshing', 'reloading'])\n\nconst initStateSchema = object({\n  mainDocument: mainDocumentSchema,\n  iframe: object({\n    status: iframeStatusSchema,\n  }),\n  visualEditing: object({overlaysEnabled: boolean()}),\n})\n\nconst INITIAL_PRESENTATION_STATE = {\n  mainDocument: false,\n  iframe: {\n    status: 'loading',\n  },\n  visualEditing: {\n    overlaysEnabled: false,\n  },\n} as const satisfies PresentationState\n\nexport function presentationReducerInit(\n  state: Readonly<Partial<PresentationState>>,\n): Readonly<PresentationState> {\n  return parse(initStateSchema, {...INITIAL_PRESENTATION_STATE, ...state})\n}\n\nexport type DispatchPresentationAction = Dispatch<Readonly<PresentationAction>>\n"],"names":["DEFAULT_TOOL_ICON","ComposeIcon","DEFAULT_TOOL_NAME","DEFAULT_TOOL_TITLE","COMMENTS_INSPECTOR_NAME","EDIT_INTENT_MODE","MAX_TIME_TO_OVERLAYS_CONNECTION","API_VERSION","MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL","LIVE_QUERY_CACHE_BATCH_SIZE","LIVE_QUERY_CACHE_SIZE","POPUP_CHECK_INTERVAL","keysOf","value","Object","keys","setKey","source","key","props","options","Observable","observer","subscribe","pipe","switchMap","object","keyObservables","map","isObservable","from","val","of","wait","combineLatest","pairs","reduce","acc","mergeAll","scan","INITIAL_STATE","locations","getDocumentId","isReference","_ref","_id","undefined","cleanPreviewable","id","previewable","clean","listen","fields","store","query","join","params","listenQuery","perspective","observeDocument","paths","currentValue","headlessPaths","filter","path","length","Set","snapshot","leads","forEach","head","tail","push","next","res","tails","isRecord","observeForLocations","documentId","resolver","documentStore","select","values","String","split","_type","doc","get","resolve","useDocumentLocations","$","_c","resolvers","type","useDocumentStore","locationsState","setLocationsState","useState","locationsStatus","setLocationsStatus","t0","bb0","t1","_result","result","t2","sub","state","unsubscribe","useEffect","t3","status","presentationLocaleNamespace","presentationUsEnglishLocaleBundle","defineLocaleResourceBundle","locale","namespace","resources","PresentationContext","createContext","usePresentationTool","throwOnMissingContext","presentation","useContext","Error","useCurrentPresentationToolName","name","TONE_ICONS","positive","InfoOutlineIcon","caution","WarningOutlineIcon","critical","ErrorOutlineIcon","LocationsBanner","isResolving","schemaType","showPresentationTitle","message","tone","len","t","useTranslation","expanded","setExpanded","toggle","useCallback","v","title","count","jsx","Card","jsxs","margin","Flex","Box","Text","createElement","Fragment","Spinner","ChevronRightIcon","transform","transition","Stack","l","index","href","preview","LocationItem","documentType","node","active","toolName","currentPresentationToolName","isCurrentTool","navigate","structureParams","intent","mode","presentationLinkProps","useIntentLink","handleCurrentToolClick","t4","onClick","t5","Symbol","for","DesktopIcon","t6","t7","t8","t9","PresentationDocumentContext","LocationStack","styled","rem","PresentationDocumentHeader","context","locate","contextOptions","options_0","idx","PresentationDocumentProvider","children","parent","parentRegister","register","optionsArray","setOptionsArray","_temp","prev","concat","prev_0","o","options_1","registerEffectEvent","useEffectEvent","useLayoutEffect","openInStructure","defineDocumentFieldAction","useAction","workspace","useWorkspace","navigateIntent","useRouter","defaultStructureTool","useMemo","findStructureTool","tools","hidden","icon","MasterDetailIcon","onAction","pathToString","renderAsButton","results","match","canHandleIntent","tool","modeMatches","preservedSearchParamKeys","getIntentState","routerState","payload","searchParams","_searchParams","includes","URLSearchParams","window","location","search","getPublishedId","entries","encodeJsonParams","uuid","PresentationSpinner","width","router","route","create","__unsafe_disableScopedSearchParams","intents","PresentationTool","lazy","BroadcastDisplayedDocument","defineLocations","defineDocuments","presentationTool","definePlugin","console","warn","hasLocationsResolver","PresentationDocumentInput","isDocumentSchemaType","renderDefault","Suspense","canHandleCreateIntent","template","canHandleEditIntent","i18n","bundles","document","unstable_fieldActions","a","form","components","input","component","PresentationNavigateContext","usePresentationNavigate","PresentationParamsContext","usePresentationParams","SharedStateContext","useSharedState","setValue","getGlobalConfig","config2","lang","abortEarly","abortPipeEarly","skipPipe","store2","getGlobalMessage","store3","getSchemaMessage","store4","getSpecificMessage","reference","_stringify","getPrototypeOf","constructor","_addIssue","label","dataset","other","expected","expects","received","issue","kind","requirement","issues","isSchema","typed","_isAllowedObjectKey","ValiError","minLength","async","_run","getFallback","schema","fallback","fallback2","getDefault","default","boolean","value2","valueDataset","pathItem","origin","unshift","optional","wrapped","args","picklist","record","entryKey","entryValue","keyDataset","string","unknown","parse","pipe2","nextAction","ACTION_IFRAME_LOADED","ACTION_IFRAME_REFRESH","ACTION_IFRAME_RELOAD","ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE","presentationReducer","action","iframe","toggleVisualEditingOverlays","visualEditing","overlaysEnabled","enabled","mainDocumentSchema","iframeStatusSchema","initStateSchema","mainDocument","INITIAL_PRESENTATION_STATE","presentationReducerInit"],"mappings":"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","x_google_ignoreList":[22]}